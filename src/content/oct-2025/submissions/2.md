---
title: Managing browser history in single-page applications 
slug: Web/API/History_API/Working_with_the_History_API
page-type: guide
---

{{DefaultAPISidebar("History API")}}

The History API enables a website to interact with the browser's session history, which is the list of pages a user has visited in a given window. As users navigate by clicking links, new pages are added to the session history. Users can move through their history with the browser's "Back" and "Forward" buttons.

Single-page applications (SPAs) update content dynamically without reloading the page. Although users see new content, the browser never loads a new document. This creates a problem: the browser's "Back" and "Forward" buttons don't work as expected because no new history entries are created.

This guide shows you how to use {{domxref("History.pushState()")}} and {{domxref("History.replaceState()")}} to add and update history entries in SPAs. These methods let you update your app's URL and session history even when users aren't loading new pages, so the browser's "Back" and "Forward" buttons work with dynamically changed content.

> [!NOTE]
> The {{domxref("History")}} interface also provides methods to **programmatically navigate** through session history:
> - {{domxref("History.back()")}} - Move backward one page (like clicking the browser's Back button)
> - {{domxref("History.forward()")}} - Move forward one page (like clicking the browser's Forward button)
> - {{domxref("History.go()")}} - Move to a specific page in the history (e.g., `history.go(-2)` goes back two pages)
>
> Use these when you need to navigate the user through history programmatically, such as providing custom navigation buttons in your UI. This guide focuses on the related but different task of **creating and modifying** history entries. For more information about these navigation methods, see the [History API overview](/en-US/docs/Web/API/History_API).

## How it works

The History API provides two key methods for managing session history in single-page applications, plus an event for responding to navigation:

| API | Purpose | Use case |
|--------|---------|----------|
| {{domxref("History.pushState()")}} | Adds a new entry to the session history | When the user navigates to new content (like clicking a link) |
| {{domxref("History.replaceState()")}} | Updates the current session history entry | When you need to modify the current entry without adding to the history stack |
| {{domxref("Window.popstate_event", "popstate")}} event | Fires when the user navigates through history | Listen for this to restore the page when users click Back/Forward buttons |

Both `pushState()` and `replaceState()` take a `state` parameter containing any {{Glossary("Serializable_object", "serializable object")}}. This state object is stored with the history entry and later returned in the `popstate` event.

When the browser navigates to a history entry (for example, when the user presses the "Back" or "Forward" button), it fires a {{domxref("Window.popstate_event", "popstate")}} event. This event contains the state object you originally passed to `pushState()` or `replaceState()`, allowing you to restore the page to its previous state.

## Using the History API with single-page applications

This section walks through how to use the History API to maintain browser navigation in {{Glossary("SPA", "single-page applications")}} (SPAs). You'll see how `pushState()` and `replaceState()` solve a common problem where the browser's Back and Forward buttons stop working as users expect.

### The problem: Browser history breaks in SPAs

SPAs dynamically update content without loading new pages. When a user clicks a link in a traditional website, the browser loads a new page and adds an entry to the history stack. In an SPA, clicking a link updates the page content using JavaScript, but doesn't trigger a page load.

**This breaks the Back button.** When users click the browser's "Back" button, they expect to return to the previous content. But since no new page was loaded, "Back" takes them to whatever page they visited *before* opening the SPA - not to the previous state within the SPA.

### Example user journey

1. User opens an SPA showing a "Cat" article
2. User clicks a link to see "Eagle" - the page updates with eagle content
3. User clicks a link to see "Lion" - the page updates with lion content
4. User clicks the browser's "Back" button

**What the user expects:** To see the "Eagle" article again

**What actually happens:** The browser exits the entire SPA and goes back to whatever site they visited before opening it

From the user's perspective, they clicked links and saw new content - those feel like new pages. But the browser never created history entries for those navigation events. It only knows about the initial page load.

### The solution: pushState() and replaceState()

The `pushState()`, `replaceState()`, and `popstate` event solve this by letting you:
- Create history entries when content changes (even without page loads)
- Store the data needed to restore each state
- Respond when users navigate back/forward through those entries

## Building the solution: A step-by-step walkthrough

The following sections walk through how to build this functionality step by step, using an animal navigation demo as an example. The code shows you how to fix the broken Back button by creating history entries and responding to navigation events.

**Want to try it yourself first?** You can see the [live demo](https://mdn.github.io/dom-examples/history-api/) in action - click between different animals and use your browser's Back/Forward buttons to see how the History API makes navigation work. You can also [view the source on GitHub](https://github.com/mdn/dom-examples/tree/main/history-api) or run it locally:

```bash
# Clone the repo and navigate to the example
git clone https://github.com/mdn/dom-examples.git
cd dom-examples/history-api

# Start a local server (needed for fetch to work)
# Choose one of these options:
python3 -m http.server 8000        # Python 3
npx http-server -p 8000            # Node.js (via npx)
php -S localhost:8000              # PHP

# Then open http://localhost:8000 in your browser
```

## Fixing the broken navigation with `pushState()`

To fix the broken Back button behavior, you need to create a history entry each time the user navigates to new content. The `pushState()` method adds an entry to the browser's session history, making it appear as though a new page was loaded.

Here's an example using the animal SPA scenario. When the user clicks a link to view a different animal, this code fetches the new content, updates the page, and then calls `pushState()` to create a history entry:

```js
document.addEventListener("click", async (event) => {
  const creature = event.target.getAttribute("data-creature");
  if (creature) {
    event.preventDefault();
    try {
      // Fetch the new content
      const response = await fetch(`creatures/${creature}.json`);
      const result = await response.json();

      // Update the page with the new content
      displayContent(result);

      // ↓ NEW: Create a history entry for this navigation
      history.pushState(result, "", creature);
    } catch (err) {
      console.error(err);
    }
  }
});
```

The new line is `history.pushState(result, "", creature);` which creates a history entry after updating the page content.

This creates a new browser history entry with three arguments:

| Argument | Value | Purpose |
|----------|-------|---------|
| **State object** | `result` | The fetched content (JSON data). The browser stores this and returns it in the `popstate` event when the user navigates back to this entry. |
| **Title** | `""` | Unused (legacy parameter). Always pass an empty string. |
| **URL** | `creature` | The URL to display in the browser's address bar (like `/eagle`). Must be same-origin with the current page. |

Now when users click "Back", the browser will navigate through the history entries you created, rather than exiting the SPA entirely.

## Handling Back/Forward navigation with the `popstate` event

Adding history entries with `pushState()` is only half the solution. You also need to restore the correct content when users navigate backward or forward through those entries.

When users click the "Back" or "Forward" buttons, the browser fires a `popstate` event. This event includes the state object you stored when you called `pushState()`.

**Example scenario:**
1. User clicks "Eagle" link → page updates, `pushState()` stores eagle data as entry A
2. User clicks "Lion" link → page updates, `pushState()` stores lion data as entry B
3. User presses "Back" button → browser navigates to entry A and fires `popstate` event with the eagle data

You can listen for this event and restore the page content:

```js
window.addEventListener("popstate", (event) => {
  if (event.state) {
    // The state object contains the data stored with pushState()
    // Use it to restore the page to its previous state
    displayContent(event.state);
  }
});
```

The `event.state` property contains the same JSON object you passed to `pushState()`, so you can use the same `displayContent()` function to render it. This completes the loop: users can now navigate forward and backward through your SPA just like a traditional multi-page website.

## Handling the initial page load with `replaceState()`

There's one more edge case to handle: the initial page load.

When a user first loads your SPA, the browser creates a history entry, but that entry has no state object (since it was a real page load, not a `pushState()` call). This creates a problem:

**Example scenario:**
1. User loads SPA at `/creatures` (shows "Cat" by default) → browser creates history entry with **no state**
2. User clicks "Eagle" link → `pushState()` creates entry with eagle state
3. User presses "Back" → browser navigates to initial entry

**The problem:** The `popstate` event fires, but `event.state` is `null`, so your code doesn't know what content to restore.

**The solution:** Use `replaceState()` on page load to add a state object to the initial history entry. Unlike `pushState()`, which adds a new entry, `replaceState()` modifies the current entry.

Here's how to capture the initial state when the page first loads:

```js
// Run this when the page first loads
const image = document.querySelector("#photo");
const initialState = {
  description: document.querySelector("#description").textContent,
  image: {
    src: image.getAttribute("src"),
    alt: image.getAttribute("alt"),
  },
  name: "Home",
};
history.replaceState(initialState, "", document.location.href);
```

This code runs on page load and:
1. Collects the current page content (description, image, name)
2. Calls `replaceState()` to add this data to the current history entry (not create a new one)

The `initialState` object uses the same structure as the JSON fetched for other animals, so your existing `popstate` handler and `displayContent()` function work without modification.

Now when users navigate back to the initial page, the `popstate` event contains the initial state, and the page restores correctly.

## Complete History API example

You can find this complete example at <https://github.com/mdn/dom-examples/tree/main/history-api>, and see the demo live at <https://mdn.github.io/dom-examples/history-api/>.

## See also

- [History API](/en-US/docs/Web/API/History_API)
- {{domxref("window.history", "history")}} global object
